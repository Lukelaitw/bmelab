# Arduino 藍牙數據讀取問題診斷指南

## 問題分析

根據您的程式碼分析，發現以下可能導致 Arduino 數據無法正確讀取的問題：

### 1. **藍牙通訊協議不匹配**
- **問題**: Arduino 使用 `SoftwareSerial` (經典藍牙)，Flutter 使用 `flutter_blue_plus` (BLE)
- **影響**: 兩種通訊方式不相容，無法建立有效連接

### 2. **數據格式問題**
- **問題**: 數據傳輸可能被截斷或格式不正確
- **影響**: Flutter 無法正確解析 Arduino 發送的數據

### 3. **藍牙模組配置問題**
- **問題**: 藍牙模組可能未正確配置為 BLE 模式
- **影響**: 無法被 Flutter 應用程式發現和連接

## 解決方案

### 方案 1: 使用 BLE 藍牙模組 (推薦)

#### 硬體需求:
- 替換現有藍牙模組為 BLE 模組 (如 HM-10, ESP32, 或 nRF52832)
- 確保模組支援 BLE 通訊

#### Arduino 程式碼修改:
```cpp
#include <BLEDevice.h>
#include <BLEServer.h>
#include <BLEUtils.h>
#include <BLE2902.h>

// BLE 服務和特徵值定義
BLEServer* pServer = NULL;
BLECharacteristic* pCharacteristic = NULL;
bool deviceConnected = false;
bool oldDeviceConnected = false;

// 服務 UUID
#define SERVICE_UUID        "12345678-1234-1234-1234-123456789abc"
// 特徵值 UUID
#define CHARACTERISTIC_UUID "87654321-4321-4321-4321-cba987654321"

class MyServerCallbacks: public BLEServerCallbacks {
    void onConnect(BLEServer* pServer) {
      deviceConnected = true;
    };

    void onDisconnect(BLEServer* pServer) {
      deviceConnected = false;
    }
};

void setup() {
  Serial.begin(115200);
  
  // 初始化 BLE
  BLEDevice::init("Arduino_ECG_Device");
  pServer = BLEDevice::createServer();
  pServer->setCallbacks(new MyServerCallbacks());

  BLEService *pService = pServer->createService(SERVICE_UUID);

  pCharacteristic = pService->createCharacteristic(
                      CHARACTERISTIC_UUID,
                      BLECharacteristic::PROPERTY_READ |
                      BLECharacteristic::PROPERTY_WRITE |
                      BLECharacteristic::PROPERTY_NOTIFY
                    );

  pCharacteristic->setValue("Hello World");
  pService->start();

  BLEAdvertising *pAdvertising = BLEDevice::getAdvertising();
  pAdvertising->addServiceUUID(SERVICE_UUID);
  pAdvertising->setScanResponse(false);
  pAdvertising->setMinPreferred(0x0);
  BLEDevice::startAdvertising();
  Serial.println("BLE 設備已啟動，等待連接...");
}

void loop() {
  if (deviceConnected) {
    // 讀取 ADC 數據
    int adcValue = analogRead(A0);
    double voltage = (adcValue * 5.0) / 1023.0;
    
    // 發送數據
    String dataString = "ADC_DATA:" + String(adcValue) + "," + String(voltage, 3);
    pCharacteristic->setValue(dataString.c_str());
    pCharacteristic->notify();
    
    Serial.println("發送數據: " + dataString);
    delay(100);
  }
  
  // 處理斷開連接
  if (!deviceConnected && oldDeviceConnected) {
    delay(500);
    pServer->startAdvertising();
    Serial.println("開始廣播...");
    oldDeviceConnected = deviceConnected;
  }
  
  if (deviceConnected && !oldDeviceConnected) {
    oldDeviceConnected = deviceConnected;
  }
}
```

### 方案 2: 修改現有藍牙模組配置

#### 1. 檢查藍牙模組設定
```cpp
// 在 Arduino 程式碼中添加藍牙模組配置
void setup() {
  Serial.begin(9600);
  BTSerial.begin(9600);
  
  // 等待藍牙模組初始化
  delay(2000);
  
  // 發送 AT 指令配置藍牙模組
  BTSerial.println("AT+NAME=Arduino_ECG");
  delay(1000);
  BTSerial.println("AT+BAUD=9600");
  delay(1000);
  BTSerial.println("AT+ROLE=0"); // 設為從機模式
  delay(1000);
  
  Serial.println("藍牙模組配置完成");
}
```

#### 2. 改進數據傳輸
```cpp
void sendData(int adcValue, double voltage) {
  // 添加數據校驗
  String dataString = "ADC_DATA:" + String(adcValue) + "," + String(voltage, 3);
  dataString += "\n"; // 確保數據完整性
  
  // 檢查藍牙連接狀態
  if (BTSerial.availableForWrite() > 0) {
    BTSerial.print(dataString);
    Serial.println("發送數據: " + dataString);
  } else {
    Serial.println("藍牙緩衝區已滿，跳過發送");
  }
}
```

### 方案 3: 使用 WiFi 通訊 (替代方案)

#### 使用 ESP32 的 WiFi 功能:
```cpp
#include <WiFi.h>
#include <WebServer.h>

const char* ssid = "您的WiFi名稱";
const char* password = "您的WiFi密碼";

WebServer server(80);

void setup() {
  Serial.begin(115200);
  
  // 連接 WiFi
  WiFi.begin(ssid, password);
  while (WiFi.status() != WL_CONNECTED) {
    delay(1000);
    Serial.println("連接WiFi中...");
  }
  
  Serial.println("WiFi連接成功");
  Serial.print("IP地址: ");
  Serial.println(WiFi.localIP());
  
  // 設置 Web 服務器
  server.on("/", handleRoot);
  server.on("/data", handleData);
  server.begin();
}

void loop() {
  server.handleClient();
}

void handleData() {
  int adcValue = analogRead(A0);
  double voltage = (adcValue * 5.0) / 1023.0;
  
  String jsonData = "{\"adc\":" + String(adcValue) + ",\"voltage\":" + String(voltage, 3) + "}";
  server.send(200, "application/json", jsonData);
}
```

## 調試步驟

### 1. 檢查硬體連接
- 確認藍牙模組的 TX/RX 接線正確
- 檢查電源供應是否穩定
- 確認 Arduino 和藍牙模組的接地連接

### 2. 測試藍牙通訊
```cpp
// 在 Arduino 中添加測試程式碼
void testBluetooth() {
  if (BTSerial.available()) {
    String received = BTSerial.readString();
    Serial.println("收到: " + received);
    
    if (received == "TEST") {
      BTSerial.println("OK");
      Serial.println("發送回應: OK");
    }
  }
}
```

### 3. 檢查 Flutter 應用程式
- 確認藍牙權限已授予
- 檢查設備掃描是否找到 Arduino
- 查看控制台輸出是否有錯誤訊息

### 4. 使用序列埠監視器調試
- 打開 Arduino IDE 的序列埠監視器
- 觀察 Arduino 是否正確發送數據
- 檢查是否有錯誤訊息

## 常見問題解決

### 問題 1: 找不到藍牙設備
**解決方案**:
- 確認藍牙模組已正確配對
- 檢查藍牙模組是否處於可發現模式
- 嘗試重新配對設備

### 問題 2: 連接後無法接收數據
**解決方案**:
- 檢查數據格式是否正確
- 確認波特率設定一致
- 檢查藍牙緩衝區是否溢出

### 問題 3: 數據不穩定
**解決方案**:
- 降低發送頻率
- 增加數據校驗
- 檢查電源供應穩定性

## 建議的測試流程

1. **硬體測試**: 使用序列埠監視器確認 Arduino 程式碼正常運行
2. **藍牙測試**: 使用手機藍牙設定確認可以發現和連接設備
3. **數據測試**: 使用簡單的測試程式確認數據傳輸正常
4. **應用程式測試**: 在 Flutter 應用程式中測試數據接收

## 聯絡支援

如果問題仍然存在，請提供以下資訊：
- Arduino 型號和藍牙模組型號
- 序列埠監視器的輸出
- Flutter 應用程式的錯誤訊息
- 硬體連接圖



